/**
 * please do not edit this file, and do not lose time trying to hack into the progress api, you actually need to implement those steps to continue the game ;)
 * and it is secured...
 */
const Logger = require('../log/logger');
const conf = require('../../conf');
const client = require('./progress-client');
const JoinRequestPacketDecoder = require('../../tobeimpl/step-2/JoinRequestPacketDecoder');
const pg = require('./Progress');
const logger = Logger.child({service: 'review-service'});

let loopCallback;

/**
 * @type {{
 * hackerSteps: [{tag: string, validated: boolean, timestamp: number}],
 * geekInDangerSteps: [{tag: string, validated: boolean, timestamp: number}]
 * }}
 */
let progress = new pg.Progress();

const init = () => {
  loopCallback = setInterval(solveNextChallenge, 10000 + (Math.random() * 5000));
  solveNextChallenge();
};

/**
 * This method will be called every 10-ish seconds to request, solve and submit the different challenges
 * which cannot be tested from the remote server.
 * @returns {Promise<void>}
 */
const solveNextChallenge= async () => {
  progress = await client.getProgress();
  if (!progress.hackerSteps.find(step => step.tag === pg.HACKER_STEP_JOIN_REQUEST_SUPPORTED).validated) {
    return await solveJoinRequestSupportedChallenge();
  }
  if (!progress.hackerSteps.find(step => step.tag === pg.HACKER_STEP_JOIN_REQUEST_DECODE).validated) {
    return await solveJoinRequestDecodeChallenge();
  }
  // If all challenges have been solved, no need to call it anymore.
  clearInterval(loopCallback);
};

const solveJoinRequestSupportedChallenge = async () => {
  // Request challenge from progress client
  const challenge = await client.requestJoinRequestSupportedChallenge();
  logger.debug(`Challenge ${challenge.id} received`);

  // Solve challenge
  let result = {
    challengeId: challenge.id,
    errors: undefined,
    content: {messages: []}
  };

  try {
    challenge.content.messages.forEach(message => {
      let packetDecoder = new JoinRequestPacketDecoder(message.topic, message.message);
      result.content.messages.push({supported: !!packetDecoder.isSupported()});
    });
  } catch (e) {
    if (!result.errors) {
      result.errors = [];
    }
    result.errors.push(e);
  }

  // Submit challenge result
  await client.submitJoinRequestSupportedChallenge(result);
};

const solveJoinRequestDecodeChallenge = async () => {
  // Request challenge from progress client
  const challenge = await client.requestJoinRequestDecodeChallenge();
  logger.debug(`Challenge ${challenge.id} received`);

  // Solve challenge
  let result = {
    challengeId: challenge.id,
    errors: undefined,
    content: {messages: []}
  };

  try {
    challenge.content.messages.forEach(message => {
      let packetDecoder = new JoinRequestPacketDecoder(message.topic, message.message);
      result.content.messages.push({supported: packetDecoder.isSupported(), decodedPacket: JSON.stringify(packetDecoder.decode())});
    });
  } catch (e) {
    if (!result.errors) {
      result.errors = [];
    }
    result.errors.push(e);
  }

  // Submit challenge result
  await client.submitJoinRequestDecodeChallenge(result);
};

module.exports = {
  init
};
